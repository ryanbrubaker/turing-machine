// Generated by CoffeeScript 1.3.1
(function() {
  var State, StateMachine, Tape, currentOperations, drawThickLine, init, nextOperation, shiftTapeLeft, shiftTapeRight, shiftTapeStep, stateMachine, tape;

  State = (function() {

    State.name = 'State';

    function State(nextState) {
      this.operations = {};
      this.nextState = nextState;
    }

    State.prototype.addOperations = function(character, operations) {
      return this.operations[character] = operations;
    };

    State.prototype.operationsFor = function(character) {
      if (this.operations[character] != null) {
        return this.operations[character];
      } else {
        throw new Error('Encountered invalid symbol.');
      }
    };

    State.prototype.nextState = function() {
      return this.nextState;
    };

    return State;

  })();

  StateMachine = (function() {

    StateMachine.name = 'StateMachine';

    function StateMachine() {
      this.states = {};
      this.currentState = null;
    }

    StateMachine.prototype.setup = function(states) {
      var currentStateName, i, initialStateName, newState, operations, state, stateName, _i, _j, _len, _ref, _ref1;
      this.states = {};
      this.currentState = null;
      if (states.length === 0) {
        throw new Error("You must specify at least one state.");
      }
      initialStateName = null;
      currentStateName = null;
      for (_i = 0, _len = states.length; _i < _len; _i++) {
        state = states[_i];
        if (currentStateName === '' && state[0] === '') {
          throw new Error('State must have a name.');
        }
        if (state[1] === '') {
          throw new Error('State must specify a character.');
        }
        if (!this.validOperations(state[2])) {
          throw new Error('Allowed operations are "L", "R", "E", "P[x]"');
        }
        operations = state[2].split(',');
        for (i = _j = 0, _ref = operations.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
          operations[i] = operations[i].trim();
        }
        if (state[0] === '') {
          this.states[currentStateName].addOperations(state[1], operations);
        } else {
          currentStateName = state[0];
          if (!(initialStateName != null)) {
            initialStateName = currentStateName;
          }
          newState = new State(state[3]);
          newState.addOperations(state[1], operations);
          this.states[currentStateName] = newState;
        }
      }
      _ref1 = this.states;
      for (stateName in _ref1) {
        state = _ref1[stateName];
        if (!(this.states[state.nextState] != null)) {
          throw new Error('Result state does not exist.');
        }
      }
      return this.currentState = this.states[initialStateName];
    };

    StateMachine.prototype.validOperations = function(operationList) {
      var operation, operations, valid, _i, _len;
      valid = true;
      operations = operationList.split(',');
      for (_i = 0, _len = operations.length; _i < _len; _i++) {
        operation = operations[_i];
        operation = operation.trim();
        valid = valid && ((operation === 'L' || operation === 'R' || operation === 'E') || (operation[0] === 'P' && operation.length === 2));
      }
      return valid;
    };

    StateMachine.prototype.processState = function(character) {
      var operations;
      if (character === "") {
        character = 'none';
      }
      if (null === this.currentState) {
        throw new Error("Invalid state.");
      } else {
        operations = this.currentState.operationsFor(character).slice(0);
        this.currentState = this.states[this.currentState.nextState];
        return operations;
      }
    };

    return StateMachine;

  })();

  Tape = (function() {

    Tape.name = 'Tape';

    function Tape() {
      this.currentPos = 0;
      this.printedCharacters = [];
    }

    Tape.prototype.doOperation = function(operation) {
      switch (operation) {
        case "E":
          return this.printedCharacters[this.currentPos] = "";
        case "L":
          return this.currentPos -= 1;
        case "R":
          this.currentPos += 1;
          if (this.currentPos > this.printedCharacters.length) {
            return this.printedCharacters[this.currentPos] = "";
          }
          break;
        default:
          return this.printedCharacters[this.currentPos] = operation[1];
      }
    };

    Tape.prototype.currentCharacter = function() {
      return this.printedCharacters[this.currentPos] || '';
    };

    return Tape;

  })();

  drawThickLine = function(xCoord) {
    var context;
    context = document.getElementById("paperTapeCanvas").getContext('2d');
    context.lineWidth = 5;
    context.beginPath();
    context.moveTo(xCoord, 0);
    context.lineTo(xCoord, 50);
    context.closePath();
    return context.stroke();
  };

  shiftTapeStep = function(xCoordFunc, stepNum, stepIndices) {
    var context, i, _i, _len;
    context = document.getElementById("paperTapeCanvas").getContext('2d');
    context.lineWidth = 1;
    if (stepNum <= 100) {
      context = document.getElementById("paperTapeCanvas").getContext('2d');
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      context.font = "bold 48px sans-serif";
      for (_i = 0, _len = stepIndices.length; _i < _len; _i++) {
        i = stepIndices[_i];
        context.beginPath();
        context.moveTo(xCoordFunc(i, stepNum), 0);
        context.lineTo(xCoordFunc(i, stepNum), 50);
        context.strokeStyle = "#000";
        context.closePath();
        context.stroke();
      }
      stepNum += 1;
      return setTimeout(function() {
        return shiftTapeStep(xCoordFunc, stepNum, stepIndices);
      }, 1);
    } else {
      drawThickLine(400);
      return drawThickLine(500);
    }
  };

  shiftTapeRight = function() {
    return shiftTapeStep(function(boxIndex, stepNum) {
      return boxIndex * 100 + stepNum;
    }, 0, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
  };

  shiftTapeLeft = function() {
    return shiftTapeStep(function(boxIndex, stepNum) {
      return boxIndex * 100 - stepNum;
    }, 0, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
  };

  stateMachine = new StateMachine();

  currentOperations = [];

  tape = new Tape();

  nextOperation = function() {
    var operation;
    if (0 === currentOperations.length) {
      currentOperations = stateMachine.processState(tape.currentCharacter());
    } else {
      operation = currentOperations.shift();
      tape.doOperation(operation);
      switch (operation) {
        case "E":
          alert("e");
          break;
        case "L":
          shiftTapeLeft();
          break;
        case "R":
          shiftTapeRight();
          break;
        default:
          alert("p");
      }
    }
    return setTimeout(nextOperation, 1000);
  };

  init = function() {
    $(function() {
      return $('#start-machine').on('click', function() {
        var i, row, stateRawData, stateRows, statesRawData, td, _i, _j, _len;
        try {
          stateRows = $('#stateMachineTable .addedRow');
          statesRawData = [];
          for (_i = 0, _len = stateRows.length; _i < _len; _i++) {
            row = stateRows[_i];
            stateRawData = [];
            for (i = _j = 1; _j <= 4; i = ++_j) {
              td = $(row).children()[i];
              stateRawData.push($(td).children()[0].value.trim());
            }
            statesRawData.push(stateRawData);
          }
          stateMachine.setup(statesRawData);
        } catch (error) {
          alert(error);
        }
        currentOperations = stateMachine.processState("");
        return nextOperation();
      });
    });
    return $(function() {
      return $('#stateMachineTable').on('click', '.icon-plus-sign', function(eventObject) {
        var newRow;
        newRow = $('#stateRowTemplate').clone();
        newRow.id = '';
        $('#stateMachineTable').append(newRow);
        return $(eventObject.target).parent().empty();
      });
    });
  };

  $(document).ready(init);

}).call(this);
